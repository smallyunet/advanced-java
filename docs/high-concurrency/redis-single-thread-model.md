## Interview questions
What is the difference between redis and memcached? What is the thread model of redis? Why does redis single thread support high concurrency?

## Psychnological analysis of interviewers
This is the most basic question when asking redis. The most basic internal principle and feature of redis is that redis is actually a **single threaded working model**. If you don't know this, then play redis. At the time, if something went wrong, didn't you know anything?

It is also possible that the interviewer will ask you the difference between redis and memcached, but memcached is a caching scheme commonly used by major internet companies in the early years, but not it is basically redis in recent years, and no company uses memcached.

## Analysis of interview questions

### What is the difference between redis and memcached?

#### Redis supports complex data structures
Compared to memcached, redis has [more data structures](/docs/high-concurrency/redis-data-types.md) to support richer data operations. Redis would be a good choice if you need caching to support more complex structures and operations.

#### Redis native support cluster mode
In the redis 3.x version, cluster mode can be supported, and memcached does not have a native clustermode. It relies on the client to implement fragmentation to the cluster.

#### Performance comparison
Since redis only uses **single core**, and memcached can use **multicore**, on average, redis on each core has better performance than memcached when storing small data. In data above 100k, memcached performance is higher than redis. Although redis has recently optimized the performance of storing big data, it is still slightly inferior to memcached.

### Redis threading model
Redis internally uses the file event handler `file event handler`. This file event handler is single-threaded, so redis is called a single-threaded model. It uses the IO multiplexing mechanism to simultaneously listen to multiple sockets, pushes the socket that generates the event into the memory queue, and the event dispatcher selects the corresponding event handler for processing according to the event type on the socket.

The strcture of the file event handler consists of four parts:

- Multiple sockets
- IO multiplexing program
- File Event Dispatcher 
- Event handler (connection answer hadnler, command request handler, command reply handler)

Multiple sockets may generate different operations concurrently, each operation corresponds to a different file event, but the IO multiplexer will isten to multiple sockes, queue the event-generating sockets in the queue, and the event dispatcher will each time A socket is taken from the queue and sent to the correspinding event handler for processing according to the event type of the socket.

Look at the communication process between the client and redis:

![redis-single-thread-model](/images/redis-single-thread-model.png)

Understand that communication is done through sockets. Students who don't understand can go to see socket network programming first.

First, when the redis server process is initialized, the server sockets `AE_READABLE` event is associated with the connection reply handler.

The client socket01 requests a connection to the server socket of the redis process. At this time, the server socket will generate an `AE_READABLE` event. After the IO multiplexer listens to the event generated by the server socket, the socket is pushed into the queue. The file event dispatcher gets the socket from the queue and hands it to the **connection response handler**. The connection answering processor creates a socket01 that can communicate with the client and associates the socket01's `AE_READABLE` event with the command request handler.

Suppose that the client sends a `set key value` request at this time. At this time, socket01 in redis will generate the `AE_READABLE` event, and the IO multiplexing program will push socket01 into the queue. At this time, the event dispatcher gets from the queue. The `AE_READABLE` event of the previous socket01 has been associated with the command request handler, the event dispatcher passes the event to the command request handler for processing. The command request handler reads the `key value` of socket01 and completes the setting of `key value` in its own memory. When the operation is complete, it associates the `AE_WRITABLE` event of socket01 with the command reply handler.

If the client is ready to receive the return result, then socket01 in redis wil fenerate an `AE_WRITABLE` event, which is also pushed into the queue. The event dispatcher finds the associated command reply handler, and the command replies to the processor to socket01. Enter a result of this operation, such as `ok`, and then unlink the `AE_WRITABLE` event of socket01 from the command reply handler.

This completes a communicateion. For a communication process with Redis, readers are recommended to read "[Redis 设计与实现——黄健宏](https://github.com/doocs/technical-books#database)" for system learning.

### Why is the redis single-threaded model so efficient?
- Pure memory operation.
- The core is based on a non-blocking IO multiplexing mecharism.
- C language implementation, in general, the C language implementation of the program "distance" operating system is closer, the execution speed is relatively faster.
- Single thread instead avoids the frequent context switching problem of multithreading, preventing the competition problem that multithreading may generate.















